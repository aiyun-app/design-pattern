
# 工厂模式类结构图

# 简单工厂

 **目的**
 
  由一个工厂对象 决定创建出哪一种产品类的实例
 
 **适用性**
 
  • 只有较少类对象需要创建；

**优点**
 
  • 客户端只需要传入工厂类正确的参数，对于如何创建对象的逻辑不需要关心；

**缺点**
  
  • 工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断 逻辑，违背开闭原则。 不易于扩展过于复杂的产品结构；
  

# 工厂方法

 **目的**
 
  定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类
 
 **适用性**
 
 在下列情况下可以使用 Factory Method模式:
 
  • 当一个类不知道它所必须创建的对象的类的时候；
  
  • 当一个类希望由它的子类来指定它所创建的对象的时候；
  
  • 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候；

**优点**
 
  • 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
  
  • 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

**缺点**
  
  • 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度；

# 抽象工厂

 **目的**
 
  提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类；
  
 **适用性**
 
  在以下情况可以使用 Abstract Factory模式
  
  • 一个系统要独立于它的产品的创建、组合和表示时；
  
  • 一个系统要由多个产品系列中的一个来配置时；
  
  • 当你要强调一系列相关的产品对象的设计以便进行联合使用时；
  
  • 当你提供一个产品类库，而只想显示它们的接口而不是实现时；
  
**优点**

  • 它分离了具体的类 Abstract Factory模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象 接口操纵实例。产品的类名也在具体工厂的实现中被分离;它们不出现在客户代码中；
  
  • 它使得易于交换产品系列 一个具体工厂类在一个应用中仅出现一次— 即在它初始化 的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变；
  
  • 它有利于产品的一致性当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而抽象工厂很容易实现这一点；

**缺点**

  • 难以支持新种类的产品 难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂接口确定了可以被创建的产品集合 ；
  
  • 支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变；
  
  **总结**
  
   从简单工厂、工厂方法再到抽象工厂就是现实社会发展的一个真实描述，当改革开发初期的时候，有很多人下海经商，成立了小作坊，只要你给钱想要什么我都能生产，随着生产的产品越来越多，小作坊赚了越来越多的钱，但是管理越来越跟不上了，小作坊生产的产品也无法满足人们的需求了。这时候必须要成立工厂，不同的工厂负责生产不同的产品，这样既能提高产品的质量、提高工作效率也利于管理。但是时代总是进步，科技总是在不断发展，现在的工厂也无法满足人们日益增长的对现代化生活对美好愿望了，工厂摇身一变，变成了现代化、高科技、人工智能工厂，每个工厂有不同对流水线，一个流水线负责生产产品对一部分，最终从不同流水线生产的产品，组合成一个完美对商品。
   
   抽象工厂关注于创建一系列相关的产品，这个相关性很重要，比如现在有两个品牌商（两个产品族）范思哲和耐克，分别生成两类产品（两个产品等级结构）服装和鞋，范思哲工厂有两个生产线或者两个生产车间，分别负责生产范思哲服装和范思哲鞋，耐克工厂同样有两个生产线，分别负责生产耐克服装和耐克鞋。
    显然，范思哲的鞋与范思哲的服装搭配穿起来更协调，耐克的鞋与耐克的服装搭配更好。如果用两个工厂方法（一个范思哲工厂方法、一个耐克工厂方法）实现上面的需求，最终可以可能会生产出一个范思哲的服装和一个耐克运动鞋，显然两个产品搭配起来有些不伦不类了（当然现实情况可能有人喜欢这样的搭配）。
    
    

