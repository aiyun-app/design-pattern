
# 工厂模式类结构图


# 工厂方法

 **目的**
 
  定义一个用于创建对象的接口，让子类决定实例化哪一个类。 Factory Method使一个类的实例化延迟到其子类
 **适用性**
  在下列情况下可以使用 Factory Method模式:
  • 当一个类不知道它所必须创建的对象的类的时候；
  • 当一个类希望由它的子类来指定它所创建的对象的时候；
  • 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候；
**优点**
  • 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
  • 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
**缺点**
  • 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度；

# 抽象工厂
 **目的**
  提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类；
 **适用性**
  在以下情况可以使用 Abstract Factory模式
  • 一个系统要独立于它的产品的创建、组合和表示时；
  • 一个系统要由多个产品系列中的一个来配置时；
  • 当你要强调一系列相关的产品对象的设计以便进行联合使用时；
  • 当你提供一个产品类库，而只想显示它们的接口而不是实现时；
**优点**
  • 它分离了具体的类 Abstract Factory模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象 接口操纵实例。产品的类名也在具体工厂的实现中被分离;它们不出现在客户代码中；
  • 它使得易于交换产品系列 一个具体工厂类在一个应用中仅出现一次— 即在它初始化 的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变；
  • 它有利于产品的一致性当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而抽象工厂很容易实现这一点；

**缺点**
  • 难以支持新种类的产品 难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂接口确定了可以被创建的产品集合 ；
  • 支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变；
  
  **总结**
    抽象工厂关注于创建一系列相关的产品，这个相关性很重要，比如现在有两个品牌商（两个产品族）范思哲和耐克、分别生成两类产品（两个产品等级结构）服装和鞋，范思哲工厂有两个生产线或者两个生产车间，分别负责生产范思哲服装和范思哲鞋，耐克工厂同样有两个生产线，分别负责生产耐克服装和耐克鞋。
    显然，范思哲的鞋与范思哲的服装搭配穿起来更协调，耐克的鞋与耐克的服装搭配更好。
    
    

